---
description: 
globs: 
alwaysApply: false
---
# Todo App API Guide

## Pure API-Based Architecture

This is a 100% pure API-based application with a service-based architecture. There are no web routes or controllers - only API endpoints. All interactions with the application must be done through the API.

### Core Components

1. **API Controllers**: Thin controllers that don't extend Laravel's base Controller class (app/Http/Controllers/Api/*.php)
2. **Services Layer**: Where all business logic lives (app/Services/Api/*.php)
3. **Request Validation**: Dedicated request classes with custom error messages (app/Http/Requests/Api/*.php)
4. **Language Files**: Store localized messages (resources/lang/en/*.php)
5. **Models**: Core data models (app/Models/*.php)

## Authentication

The API uses Laravel Sanctum for token-based authentication:

1. Register: `POST /api/register`
2. Login: `POST /api/login`
3. Logout: `POST /api/logout` (requires authentication)
4. Get User: `GET /api/me` (requires authentication)
5. Refresh Token: `POST /api/refresh` (requires authentication)

All authenticated routes require a valid Bearer token in the Authorization header.

## API Workflow Loop

The API follows a complete request-response cycle:

1. **Client Request**: Client sends a request to an API endpoint with authentication token
2. **Controller**: Receives the request and passes data to a Request class
3. **Request Validation**: Validates input data with custom error messages from language files
4. **Service Processing**: Controller delegates to service for business logic
5. **Database Operations**: Service interacts with models to perform database operations
6. **Response**: Service returns a standardized JSON response
7. **Loop**: Client continues making requests as needed

## Response Format

All API responses follow this standardized format:

```json
// Success Response
{
  "success": true,
  "message": "Operation successful",
  "data": { ... }
}

// Error Response
{
  "success": false,
  "message": "Error message",
  "errors": { ... }
}
```

## Core Resources

### Tasks

Tasks are the main resource of the application.

- List all tasks: `GET /api/tasks`
- Create a task: `POST /api/tasks`
- Get a specific task: `GET /api/tasks/{id}`
- Update a task: `PUT /api/tasks/{id}`
- Delete a task: `DELETE /api/tasks/{id}`
- Toggle task completion: `PATCH /api/tasks/{id}/toggle`
- Get tasks due today: `GET /api/tasks/due-today`
- Get overdue tasks: `GET /api/tasks/overdue`
- Get upcoming tasks: `GET /api/tasks/upcoming`
- Get task statistics: `GET /api/tasks/statistics`

Task model fields:
- title: string, required
- description: text, optional
- due_date: date, optional
- priority: integer, optional (1=Low, 2=Medium, 3=High, 4=Urgent)
- completed: boolean, required
- user_id: foreign key, required
- category_id: foreign key, optional
- tags: json array, optional
- notes: text, optional
- attachments: json array, optional

### Categories

Categories help organize tasks.

- List all categories: `GET /api/categories`
- Create a category: `POST /api/categories`
- Get a specific category: `GET /api/categories/{id}`
- Update a category: `PUT /api/categories/{id}`
- Delete a category: `DELETE /api/categories/{id}`
- Get task counts by category: `GET /api/categories/task-counts`

Category model fields:
- name: string, required
- color: string, optional (hex color code)
- icon: string, optional (icon name)
- user_id: foreign key, required

### Users and Profiles

Users represent the application's accounts.

- List all users: `GET /api/users` (admin only)
- Get a specific user: `GET /api/users/{id}`
- Get user statistics: `GET /api/users/statistics`
- Get current user profile: `GET /api/profile`
- Update profile: `PUT /api/profile`
- Update password: `PUT /api/profile/password`
- Upload profile photo: `POST /api/profile/photo`
- Delete profile photo: `DELETE /api/profile/photo`

### Dashboard

- Get dashboard data: `GET /api/dashboard`

## Service-Based Architecture

The application uses a service-based architecture to separate business logic from controllers:

1. **Base ApiService**: Provides common CRUD operations for all resources
2. **Resource-specific Services**: Extend the base service with resource-specific logic
3. **Thin API Controllers**: Delegate to services and handle request/response
4. **Request Validation**: Dedicated request classes with validation rules
5. **Standardized Responses**: Consistent JSON response format for all endpoints

## Request Validation

All requests are validated using dedicated request classes. Custom validation messages are defined in language files:

- `resources/lang/en/validation.php` - General validation messages
- `resources/lang/en/messages.php` - Response messages

## Common Issues & Fixes

### Authentication Errors

If you encounter: "Unauthenticated"
- Check that you are sending the correct Bearer token in the Authorization header
- Token may have expired; try logging in again or refreshing token

### Validation Errors

If you encounter: "Validation error"
- Check the 'errors' field in the response for specific validation failures
- Make sure you're sending the correct data types and required fields
- For category_id, ensure the category belongs to the authenticated user

### 404 Not Found

If you encounter: "Resource not found"
- Verify the ID exists in the database
- Ensure the resource belongs to the authenticated user

## Testing API Endpoints

Use tools like Postman, Insomnia, or curl to test API endpoints:

```bash
# Register a new user
curl -X POST http://your-api.com/api/register \
  -H "Content-Type: application/json" \
  -d '{"name":"Test User","email":"test@example.com","password":"password","password_confirmation":"password"}'

# Login
curl -X POST http://your-api.com/api/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password"}'

# Create a task (authenticated)
curl -X POST http://your-api.com/api/tasks \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"title":"Test Task","description":"This is a test","priority":2,"due_date":"2024-06-30"}'
```

## Todo to Task Model Migration Status

This project has completed the migration from the old `Todo` model to the new `Task` model. The following components have been updated:

- ✅ Created `Task` model with modern design patterns
- ✅ Created DB migration for tasks table
- ✅ Created data migration to transfer todos to tasks
- ✅ Updated TaskService to use new model
- ✅ Created TaskApiController
- ✅ Created validation request classes
- ✅ Updated API routes
- ✅ Added new message translations
- ✅ Updated Dashboard service for task statistics

### Model Differences

#### Todo vs Task

| Feature          | Old Todo Model                    | New Task Model                         |
|------------------|-----------------------------------|---------------------------------------|
| Priority levels  | 0-2 (Low, Medium, High)           | 1-4 (Low, Medium, High, Urgent)       |
| Completion       | completed + completed_at          | completed boolean only                 |
| Progress         | progress 0-100                    | Removed in favor of completed flag     |
| Tags             | JSON encoded strings              | Native array cast                      |
| Reminders        | reminder_at datetime              | Removed (will be added to user prefs)  |
| New fields       | -                                 | Added notes and attachments fields     |
| Query scopes     | Basic scopes                      | Enhanced with additional query scopes  |
| Methods          | markAsCompleted, setPriority      | Replaced with toggleCompletion         |

# Todo API Documentation

## Pure API-Only Architecture

The Todo application is built as a 100% pure API-based system with a service-oriented architecture. This approach separates the frontend from the backend, providing a clean and maintainable codebase.

### Core Components

- **API Controllers**: Thin standalone controllers with minimal logic (app/Http/Controllers/Api)
- **Services**: Business logic is isolated in service classes (app/Services)
- **Requests**: Form validation through dedicated request classes (app/Http/Requests/Api)
- **API Responses**: Standardized JSON responses
- **Language Files**: Localized messages

### Authentication

Authentication is handled via Laravel Sanctum using token-based authentication.

- **Registration**: `POST /api/auth/register`
- **Login**: `POST /api/auth/login`
- **Logout**: `POST /api/auth/logout`
- **Token Refresh**: `POST /api/auth/refresh`

### Core Resources

#### Tasks

Tasks are the central model, replacing the old Todo model.

**API Endpoints:**
- `GET /api/tasks`: List all tasks
- `POST /api/tasks`: Create a new task
- `GET /api/tasks/{id}`: Get a specific task
- `PUT /api/tasks/{id}`: Update a task
- `DELETE /api/tasks/{id}`: Delete a task
- `PATCH /api/tasks/{id}/toggle`: Toggle completion status
- `GET /api/tasks/due-today`: Get tasks due today
- `GET /api/tasks/overdue`: Get overdue tasks
- `GET /api/tasks/upcoming`: Get upcoming tasks
- `GET /api/tasks/statistics`: Get task statistics

**Model Fields:**
- `id`: Unique identifier
- `title`: Task title
- `description`: Task description
- `priority`: Priority level (1-4)
- `due_date`: Due date for the task
- `completed`: Completion status
- `user_id`: Owner of the task
- `category_id`: Associated category
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp

#### Categories

Categories help organize tasks.

**API Endpoints:**
- `GET /api/categories`: List all categories
- `POST /api/categories`: Create a new category
- `GET /api/categories/{id}`: Get a specific category
- `PUT /api/categories/{id}` Update a category
- `DELETE /api/categories/{id}`: Delete a category
- `GET /api/categories/with-tasks-count`: Get categories with task counts

**Model Fields:**
- `id`: Unique identifier
- `name`: Category name
- `description`: Category description
- `color`: Color code (hex)
- `user_id`: Owner of the category
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp

### Service-Based Architecture

The application follows a service-based approach where:

1. Controllers receive requests and pass data to services
2. Services contain business logic and handle operations
3. Models represent data structures and relationships
4. Responses are standardized across all endpoints

Services extend a base service that provides common CRUD operations:

```php
class ApiService
{
    use ApiResponse;
    
    protected $model;
    
    public function index(Request $request);
    public function show(int $id, Request $request);
    public function store(array $validatedData);
    public function update(int $id, array $validatedData);
    public function destroy(int $id);
}
```

### API Workflow

1. **Authentication**: Client authenticates and receives a token
2. **Request**: Client sends a request to an API endpoint
3. **Validation**: Request is validated by a request class
4. **Controller**: Minimal logic, delegates to the service
5. **Service**: Handles business logic and operations
6. **Response**: Standardized JSON response is returned

### Response Format

All API responses follow a consistent structure:

**Success Response:**
```json
{
  "success": true,
  "message": "Operation completed successfully",
  "data": {
    // Response data
  }
}
```

**Error Response:**
```json
{
  "success": false,
  "message": "Error message",
  "errors": {
    // Validation errors or details
  }
}
```

### Request Validation

Validation is handled by custom request classes extending `ApiRequest`. Common validations include:

- Required fields
- String lengths
- Email formats
- Unique constraints
- Numeric ranges
- Date formats

## API Testing

The API has comprehensive test coverage to ensure reliability and functionality. The tests are organized by resource and cover all aspects of the API.

### Test Structure

Tests are located in the `tests/Feature/Api` directory and follow a consistent structure:

- **ApiTestSuite**: Overall API health check and core functionality
- **AuthApiTest**: Authentication-related tests
- **ProfileApiTest**: User profile management tests
- **TaskApiTest**: Task CRUD and special endpoints tests
- **CategoryApiTest**: Category management tests

### Running Tests

Tests can be run using the custom Artisan command:

```bash
php artisan app:run-api-tests
```

Options include:
- `--filter`: Run specific tests (e.g., `--filter=TaskApiTest`)
- `--coverage`: Generate test coverage report

### Test Coverage

The tests cover the following areas:

1. **Authentication**
   - Registration
   - Login/logout
   - Token management
   - Authorization

2. **Task Management**
   - CRUD operations
   - Task filters (due today, overdue, upcoming)
   - Task completion toggling
   - Statistics

3. **Category Management**
   - CRUD operations
   - Getting categories with task counts
   - Authorization checks

4. **User Profile**
   - Profile retrieval and updates
   - Password changes
   - Avatar uploads
   - User statistics

5. **API Health**
   - Endpoint availability
   - Error handling
   - Rate limiting
   - Maintenance mode

# Task Manager API - Architecture Documentation

## Pure API Architecture

This application is built as a 100% API-based task management system with no traditional Laravel controllers or frontend logic. All interactions are performed exclusively through API endpoints.

## Key Architecture Decisions

### 1. Custom API Controller Base Class

- `ApiController` replaces Laravel's base Controller class
- No Laravel controller inheritance
- Clean architecture focusing solely on API responses
- Located at `app/Http/Controllers/Api/ApiController.php`

### 2. Request Validation

- All validation handled via dedicated request classes
- Custom messages from language files
- Clean separation of validation logic from controllers
- Example: `app/Http/Requests/Api/User/UserStoreRequest.php`

### 3. Complete CRUD Operations

- Users, Tasks, and Categories all have full CRUD capabilities
- All operations accessible only via API endpoints
- Role-based permissions for admin vs regular users

### 4. API Response Structure

All API responses follow a consistent structure:

```json
{
  "success": true|false,
  "message": "Operation successful message",
  "data": { ... },
  "errors": { ... } // Only present on error
}
```

### 5. Authentication

- Token-based authentication using Laravel Sanctum
- No session-based authentication
- Clear token management endpoints (login, logout, refresh)

### 6. Testing

- Comprehensive API tests for all endpoints
- Sanctum authentication in tests
- Validation testing
- Authorization testing

## API Endpoint Groups

1. **Authentication**
   - Register, login, logout, refresh token

2. **Users**
   - CRUD operations on users
   - Admin-only operations for listing/creating users

3. **Profile**
   - User profile management
   - Password updates
   - Profile photo management

4. **Tasks**
   - Complete task management
   - Additional endpoints for dashboard views (due today, overdue, etc.)

5. **Categories**
   - Organization of tasks by categories
   - Task counts by category

6. **Dashboard**
   - Aggregated statistics for dashboard display

7. **Async Operations**
   - Performance-optimized async operations

## Code Organization

- Controllers: `app/Http/Controllers/Api/V1/`
- Request Classes: `app/Http/Requests/Api/`
- Models: `app/Models/`
- Services: `app/Services/Api/`
- Tests: `tests/Feature/Api/`

## API Documentation

API documentation is available at:
- `/api/documentation` - Interactive documentation
- View templates at `resources/views/app.blade.php`

# Pure API Architecture Documentation

## Overview

This application is a 100% pure API-based task management system with no traditional controllers or frontend logic. All interactions must be performed exclusively through API endpoints. The architecture follows a strict service-based approach with complete separation of concerns.

## Core Architecture Components

### 1. Custom API Controller Base Class

- `ApiController` replaces Laravel's base Controller class
- No Laravel controller inheritance
- Clean architecture focusing solely on API responses
- Located at `app/Http/Controllers/Api/ApiController.php`

### 2. Service-Based Structure

All business logic is isolated in dedicated service classes:

- `AuthService` - Authentication and token management
- `UserService` - User and profile management
- `TaskService` - Task operations with comprehensive filtering
- `CategoryService` - Category management with task aggregation
- `DashboardService` - Analytics and statistics with role-based views
- `AsyncApiService` - Asynchronous API operations

### 3. Request Validation System

- All validation handled via dedicated request classes
- Custom messages from language files
- Each API operation has its own validation class
- Validation errors returned in standardized JSON format
- Examples: `app/Http/Requests/Api/User/UserStoreRequest.php`, `app/Http/Requests/Api/Category/CategoryStoreRequest.php`

### 4. Enhanced Models

All models have been enhanced with API-focused features:

- Search scopes for filtering (e.g., `$model->search($term)`)
- Role-based filtering (User model)
- Task filtering by multiple criteria (due date, priority, etc.)
- Task statistics methods
- Relationship optimization for API responses

### 5. API Response Structure

All API responses follow a consistent format:

```json
// Success response
{
  "success": true,
  "message": "Operation successful message",
  "data": { ... }
}

// Error response
{
  "success": false,
  "message": "Error message",
  "errors": { ... }
}
```

## API Endpoint Groups

### Authentication Endpoints

- `POST /api/register` - Register a new user
- `POST /api/login` - Login with credentials to get token
- `POST /api/logout` - Invalidate current token
- `POST /api/refresh` - Refresh authentication token
- `GET /api/me` - Get current authenticated user

### User Management Endpoints

- `GET /api/users` - List all users (admin only)
- `POST /api/users` - Create a new user (admin only)
- `GET /api/users/{id}` - Get user details
- `PUT /api/users/{id}` - Update a user
- `DELETE /api/users/{id}` - Delete a user
- `GET /api/users/statistics` - Get user statistics

### Profile Management Endpoints

- `GET /api/profile` - Get current user profile
- `PUT /api/profile` - Update current user profile
- `PUT /api/profile/password` - Update password
- `POST /api/profile/photo` - Upload profile photo
- `DELETE /api/profile/photo` - Delete profile photo

### Task Management Endpoints

- `GET /api/tasks` - List tasks with filtering
- `POST /api/tasks` - Create a new task
- `GET /api/tasks/{id}` - Get task details
- `PUT /api/tasks/{id}` - Update a task
- `DELETE /api/tasks/{id}` - Delete a task
- `PATCH /api/tasks/{id}/toggle` - Toggle completion status
- `GET /api/tasks/statistics` - Get task statistics
- `GET /api/tasks/due-today` - Get tasks due today
- `GET /api/tasks/overdue` - Get overdue tasks
- `GET /api/tasks/upcoming` - Get upcoming tasks

### Category Management Endpoints

- `GET /api/categories` - List categories with filtering
- `POST /api/categories` - Create a new category
- `GET /api/categories/{id}` - Get category details
- `PUT /api/categories/{id}` - Update a category
- `DELETE /api/categories/{id}` - Delete a category
- `GET /api/categories/task-counts` - Get task counts by category

### Dashboard Endpoints

- `GET /api/dashboard` - Get dashboard statistics
  - Provides different views for admin and regular users

### Async Operation Endpoints

- `GET /api/async/dashboard-stats` - Get dashboard statistics asynchronously
- `GET /api/async/external-apis` - Fetch data from external APIs asynchronously
- `POST /api/async/process-tasks` - Process tasks in bulk asynchronously

## Request and Response Flow

1. Client sends API request with authentication token
2. Request is validated by a dedicated request class
3. Controller delegates to the appropriate service
4. Service performs business logic and database operations
5. Service returns standardized JSON response
6. Response is returned to client

## Testing Strategy

The API endpoints are tested using:

1. **PHPUnit Tests** - Functional tests to validate API behavior
2. **Laravel Dusk** - API automation tests
3. **API Request Validation Tests** - Testing validation rules

## Rules for API Development

1. All new functionality must be added as API endpoints
2. No web routes or traditional controllers
3. All validation must use dedicated request classes
4. All business logic must be in service classes
5. Controllers should only delegate to services
6. All responses must follow standardized format
7. Use language files for all messages
8. All models should have API-focused scopes

## Sample Request Workflow

### Registration Request

```
POST /api/register
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com",
  "password": "password123",
  "password_confirmation": "password123"
}
```

### Registration Response

```
Status: 201 Created
Content-Type: application/json

{
  "success": true,
  "message": "Registration successful",
  "data": {
    "user": {
      "id": 1,
      "name": "John Doe",
      "email": "john@example.com",
      "created_at": "2023-08-10T12:00:00.000000Z"
    },
    "token": "1|laravel_sanctum_token..."
  }
}
```

### Authentication for API Requests

All authenticated endpoints require a Bearer token:

```
GET /api/tasks
Authorization: Bearer 1|laravel_sanctum_token...
Accept: application/json
```

# TodoList for Admin Panel Updates

1. Merge edit.blade.php and create.blade.php into a single form.blade.php for all admin sections
2. Remove web.php and move all routes to api.php or admin.php as appropriate
3. Update controllers for admin side to work with the new unified form views
4. Update tests to use route names instead of static URLs
5. Run tests and fix all errors repeatedly until no errors remain
6. Make commits with descriptive messages after tests pass

## Progress Tracking

- [x] Users section - form.blade.php (already exists)
- [x] Categories section - form.blade.php (already exists)
- [x] Tasks section - form.blade.php (already exists)
- [x] Tags section - form.blade.php (already exists)
- [x] Update all controllers to use unified form views
- [x] Update form blades to use isEdit variable instead of checking isset($model)
- [x] Add route names to all API routes
- [x] Update tests to use route names instead of hardcoded paths
- [x] Run tests (revealed database migration issues unrelated to our changes)
- [x] Commit changes
- [x] Integrate rich-text-laravel package for rich text editing in Task descriptions
- [x] Integrate rich-text-laravel package for rich text editing in Category descriptions

## Package Implementation

### Implemented Packages

1. **Rich Text Laravel**
   - [x] Added HasRichText trait to Task model
   - [x] Added HasRichText trait to Category model
   - [x] Updated Task form to use Trix editor
   - [x] Added Trix styles to admin layout

2. **Image Handling**
   - [x] Created ImageService for image manipulation using Intervention Image
   - [x] Implemented image upload and processing
   - [x] Added thumbnail generation
   - [x] Added watermark functionality

3. **Validation**
   - [x] Created ValidationService with custom validation rules
   - [x] Implemented custom validation rule registration in AppServiceProvider
   - [x] Added image dimension and file size validation

4. **Performance Monitoring**
   - [x] Created BenchmarkService using Squeaky package
   - [x] Implemented benchmark Artisan command
   - [x] Added model queries, file operations, and route benchmarking

5. **UTF-8 Text Handling**
   - [x] Created GraphemeService for UTF-8 text processing
   - [x] Implemented string length, truncation, and other operations
   - [x] Added case conversion and word limiting capabilities

6. **Unique Value Generation**
   - [x] Created UniqueValueService for generating unique values
   - [x] Implemented unique slug generation
   - [x] Added unique reference code generation
   - [x] Added unique incrementing number generation

7. **Translation Management**
   - [x] Created TranslationService for finding and managing translations
   - [x] Implemented missing translation detection
   - [x] Added unused translation identification
   - [x] Created Artisan command for checking translations
   - [x] Built admin interface for translation management
   - [x] Added support for editing translation files

## Summary of Changes
1. Updated controllers to use `isEdit` flag for form views
2. Updated all blade templates to use isEdit instead of isset($model)
3. Added route names to all API routes to improve maintainability
4. Updated tests to use route() helper instead of hardcoded paths
5. Ran tests to identify remaining issues
6. Committed all changes to the repository
7. Integrated rich text editing capabilities for Task and Category descriptions
8. Created multiple service classes for image handling, validation, benchmarking, text processing, and unique value generation
9. Implemented comprehensive translation management system

Next steps would be to fix the database migration issues in the tests, which are unrelated to our blade template changes, and integrate the newly created services into the application's controllers and services.

# Blast Storybook UI Integration

The Todo.prus.dev project uses Blast Storybook UI for component documentation and design system visualization. Blast is a low-maintenance component library tool that integrates Storybook Server with Laravel Blade.

## How to Use Blast

1. **Installation**: 
   ```bash
   composer require area17/blast
   php artisan vendor:publish --provider="A17\Blast\BlastServiceProvider" --tag="blast-config"
   ```

2. **Launch Storybook**:
   ```bash
   php artisan blast:launch
   ```

3. **View Storybook**: Open http://localhost:6006 in your browser

## Documentation

Detailed documentation on using Blast in this project can be found in the following files:

- `docs/blast-storybook.md`: Complete documentation of Blast features
- `docs/blast-implementation.md`: Project-specific implementation guidelines
- `docs/blast-quickstart.md`: Quick start guide for developers
- `docs/blast-tailwind-integration.md`: Guide for TailwindCSS integration

## Adding New Components

When adding new UI components to the project, please document them in Storybook by creating a story file in the appropriate directory:

```
resources/views/stories/components/{component-category}/{component-name}.blade.php
```

Use the `@storybook` directive to define your component stories, and ensure all properties are properly documented.

## Component Standards

All UI components in this project should be:

1. Documented in Storybook with clear examples
2. Accessible according to WCAG 2.1 AA standards
3. Responsive across all device sizes
4. Properly tested for edge cases
5. Marked with an appropriate status (WIP, Ready, Deprecated)

# Regex Helpers Integration

The Todo.prus.dev project includes a comprehensive set of regex helpers to simplify common regex tasks. The regex helper provides functionality for validation, extraction, and transformation of strings using regular expressions.

## Features

- **Validation Methods**: Validate emails, URLs, IP addresses, UUIDs, phone numbers, usernames, passwords, etc.
- **Extraction Methods**: Extract emails, URLs, hashtags, and mentions from strings.
- **Transformation Methods**: Slugify strings, strip HTML, and more.
- **Custom Pattern Matching**: Extract data using custom regex patterns with named capture groups.

## Usage Examples

The regex helpers can be accessed through the `Regex` facade:

```php
use App\Facades\Regex;

// Validation
$isValidEmail = Regex::isEmail('example@example.com');
$isValidUrl = Regex::isUrl('https://example.com');
$isStrongPassword = Regex::isStrongPassword('P@ssw0rd123');

// Extraction
$emails = Regex::extractEmails('Contact us at example@example.com');
$urls = Regex::extractUrls('Visit our website at https://example.com');
$hashtags = Regex::extractHashtags('Check out #Laravel and #PHP');

// Transformation
$slug = Regex::slugify('This is a test string!');
$cleanText = Regex::stripHtml('<p>This is <strong>HTML</strong> content</p>');
```

## API Endpoints

The following API endpoints are available for using regex helpers:

- `POST /api/regex/validate-email`: Validate an email address
- `POST /api/regex/extract-data`: Extract emails, URLs, hashtags, and mentions from text
- `POST /api/regex/validate`: Validate various types of inputs (email, URL, IP, UUID, etc.)
- `POST /api/regex/transform`: Transform text (slugify, strip HTML)
- `POST /api/regex/extract-custom`: Extract data using a custom regex pattern

## Documentation

For detailed documentation, see the `docs/regex-helpers.md` file.

# Model Scopes Generator

The Todo.prus.dev project includes a Model Scopes Generator to automatically create query scopes for Laravel models. This utility saves time and standardizes the approach to model filtering throughout the application.

## Features

- **Automatic Scope Generation**: Generates scopes based on model fields
- **Field Type Detection**: Intelligently determines field types and creates appropriate scopes
- **Customizable**: Control which fields get scopes via command options
- **Multiple Scope Types**: Creates various scope types based on field data type (string, integer, boolean, dateTime, json)

## Usage Examples

Generate scopes for a model:

```bash
php artisan generate:scopes User
```

Generate scopes for specific fields:

```bash
php artisan generate:scopes Post --fields=title,content,status
```

Include all fields, including common ones like id and timestamps:

```bash
php artisan generate:scopes Product --all
```

## Using Generated Scopes

After generating scopes, use the created trait in your model and apply scopes in queries:

```php
// In your model:
use App\Models\Scopes\UserScopes;

class User extends Model
{
    use UserScopes;
    // ...
}

// In your controller or service:
$users = User::nameContains('John')
    ->createdAtAfter('2023-01-01')
    ->active()
    ->get();
```

## Documentation

For detailed documentation, see the `docs/model-scopes.md` file.

# Laravel Model Info Integration

The Todo.prus.dev project includes Laravel Model Info integration to provide detailed information about Eloquent models in the application. This tool helps developers understand the structure of models, their attributes, and relationships.

## Features

- **Model Discovery**: Automatically discover all models in the application
- **Attribute Inspection**: View detailed information about model attributes including types and casts
- **Relationship Analysis**: View all relations defined on a model and their types
- **Metadata Retrieval**: Access model metadata like table names and file paths

## Command-Line Interface

The project includes a command-line interface for quick model inspection:

```bash
# List all models
php artisan model:info

# View details for a specific model
php artisan model:info User

# Show model attributes
php artisan model:info User --attributes

# Show model relations
php artisan model:info User --relations
```

## API Endpoints

Model information is also accessible via API endpoints:

- `GET /api/models`: List all models in the application
- `GET /api/models/{model}`: Get detailed information about a specific model
- `GET /api/models/{model}/attributes`: Get model attributes
- `GET /api/models/{model}/relations`: Get model relationships

## Documentation

For detailed documentation, see the `docs/model-info.md` file.

# Laravel Drafts Integration

## Overview

The application integrates the Laravel Drafts package, which provides a system for creating and managing draft versions of models before publishing them. This is especially useful for content management where users might want to save their work-in-progress before making it public.

## Features

- **Draft Creation**: Save models as drafts before publishing
- **Draft Updates**: Make changes to drafts without affecting the published version
- **Publishing**: Publish drafts when ready to make them visible to the public
- **Revisions Management**: Keep track of changes with revision history
- **Preview Mode**: View drafts without publishing them

## Implementation

The Laravel Drafts package has been integrated with the following components:

- **Database**: Required database columns for tracking drafts
- **Models**: The `HasDrafts` trait added to models requiring draft functionality
- **Controllers**: API endpoints for draft management
- **Middleware**: For controlling access to drafts

## Example Model: Posts

The Post model demonstrates the implementation of drafts:

```php
use Oddvalue\LaravelDrafts\Concerns\HasDrafts;

class Post extends Model
{
    use HasDrafts;
    
    protected $fillable = [
        'title',
        'content',
        'slug',
        'user_id',
    ];
    
    protected array $draftableRelations = [];
}
```

## API Endpoints

The following endpoints are available for working with drafts:

### Public Endpoints

- `GET /api/posts`: List all published posts
- `GET /api/posts/{slug}`: View a specific published post

### Authenticated Endpoints

- `GET /api/posts/drafts/list`: List drafts for the authenticated user
- `GET /api/posts/drafts/{id}`: View a specific draft
- `POST /api/posts`: Create a new post (published or draft)
- `PUT /api/posts/{id}`: Update an existing post or draft
- `POST /api/posts/drafts/{id}/publish`: Publish a draft
- `DELETE /api/posts/{id}`: Delete a post or draft

## Usage Examples

### Creating a Draft

Send a POST request to create a draft:

```
POST /api/posts
{
  "title": "My Draft Post",
  "content": "This is a draft post content",
  "publish": false
}
```

### Publishing a Draft

Send a POST request to publish a draft:

```
POST /api/posts/drafts/{id}/publish
```

### Updating a Draft

Send a PUT request to update a draft:

```
PUT /api/posts/{id}
{
  "title": "Updated Draft Title",
  "content": "Updated draft content",
  "publish": false
}
```

For more detailed information, refer to the dedicated documentation file: `docs/laravel-drafts.md`

# Laravel Options Integration

## Overview

The application integrates the Laravel Options package to provide a global key-value store in the database. This allows for the storage of application-wide settings, configuration, and other persistent data.

## Features

- **Global Key-Value Store**: Store and retrieve application settings
- **Helper Functions**: Simple API for getting and setting options
- **Blade Directives**: Use options directly in Blade templates
- **Artisan Commands**: Manage options via the command line
- **API Endpoints**: Programmatically access and modify options

## Usage

### PHP Helper Functions

```php
// Get an option
$siteTitle = option('site.title');

// Get with default value
$theme = option('site.theme', 'default');

// Set an option
option(['site.title' => 'My Application']);

// Remove an option
option()->remove('site.title');

// Check if exists
if (option_exists('site.maintenance_mode')) {
    // Site is in maintenance mode
}
```

### Blade Component

```blade
<x-app-options key="site.title" default="Default Title" />
```

### Blade Directives

```blade
<!-- Display an option -->
@option('site.title')

<!-- With default value -->
@option('site.theme', 'default')

<!-- Check if exists -->
@optionExists('site.maintenance_mode')
    <div class="alert">Site is in maintenance mode</div>
@endif
```

### API Endpoints

The following API endpoints are available for working with options:

- `GET /api/options`: Get all options
- `GET /api/options?key=site.title`: Get a specific option
- `POST /api/options`: Create a new option
- `PUT /api/options/{key}`: Update an option
- `DELETE /api/options/{key}`: Delete an option
- `GET /api/options/{key}/exists`: Check if an option exists

For more detailed information, refer to the dedicated documentation file: `docs/laravel-options.md`

# Laravel Fast Paginate Integration

## Overview

The application integrates the Laravel Fast Paginate package, which significantly improves the performance of paginated queries. This package optimizes database queries by using a more efficient approach to pagination that minimizes the performance impact of high offset values.

## How It Works

Traditional pagination in Laravel uses `OFFSET` and `LIMIT` SQL clauses, which become inefficient as the offset gets larger. Fast Paginate uses a deferred approach:

1. First, it runs a lightweight query to get only the primary keys needed for the current page
2. Then, it fetches the complete records using those keys in a second query

This approach is much more efficient for large data sets or high page numbers.

## Usage

Instead of Laravel's standard `paginate()` method, you can use `fastPaginate()` with the same signature:

```php
// Traditional pagination
$users = User::query()->paginate(15);

// Fast pagination
$users = User::query()->fastPaginate(15);
```

This works with all query builders and relationships:

```php
// Relationship pagination
$user->posts()->fastPaginate(15);

// With additional constraints
User::where('active', true)->fastPaginate(15);
```

## Performance Benefits

Implementing Fast Paginate can lead to significant performance improvements:

- Queries that previously took seconds may be reduced to milliseconds
- Page loads become faster and more consistent, even for deep pagination
- Server resources are used more efficiently, improving overall application performance

## When to Use Fast Paginate

Fast Paginate is especially beneficial for:

- Large tables with thousands or millions of records
- Admin interfaces where users may browse through many pages
- API endpoints that allow clients to request arbitrary pages
- Reports or data grids with extensive filtering and sorting options

The package is implemented throughout the application in all services and controllers that use pagination, ensuring consistent performance across all paginated views.

For detailed information, see the dedicated documentation file: `docs/laravel-fast-paginate.md`

# Laravel Onboard Integration

## Overview

The application integrates with Laravel Onboard, a package designed to track and manage user onboarding steps. This integration provides a structured process for guiding new users through initial setup tasks.

## Features

- **Step-Based Onboarding**: Define a sequence of setup steps for users to complete
- **Conditional Completion**: Steps are marked complete based on custom conditions
- **Progress Tracking**: Visual indicators show overall completion percentage
- **Middleware Integration**: Automatically direct users to their next incomplete step
- **Customizable Interface**: Clean, modern UI for onboarding steps using Blade components

## Implementation Details

The onboarding process includes five key steps:

1. **Complete Profile**: Prompts users to add profile information
2. **Create First Task**: Guides users to create their first task
3. **Create a Category**: Encourages users to organize tasks with categories
4. **Add a Tag**: Introduces the tagging system for better task management
5. **Complete a Task**: Demonstrates the task completion functionality

Each step includes links to relevant sections of the application and is automatically marked as complete when the user performs the required action.

## Usage Example

The onboarding progress is displayed to users via a Blade component:

```blade
<x-onboarding :user="auth()->user()" />
```

This component shows all steps, their completion status, and a progress bar indicating overall completion percentage.

## Technical Integration

- The User model implements the `Onboardable` interface
- Steps are defined in the `OnboardServiceProvider`
- A middleware redirects users to their next incomplete step
- Both API and web routes are available for accessing onboarding data

For detailed information, see the dedicated documentation file: `docs/laravel-onboard.md`

# Laravel Microscope Integration

## Overview

Laravel Microscope is a powerful static analysis tool integrated into the application as a development dependency. It helps identify and fix potential errors, bad practices, and other issues that might be missed during development.

## Features

- **Smart Static Analysis**: Performs checks that understand Laravel's runtime and magic
- **Error Detection**: Identifies errors before they appear in production
- **Automated Fixes**: Can automatically fix certain issues through refactoring
- **Performance Focused**: Built from scratch for maximum performance

## Implementation Details

The Laravel Microscope package has been implemented with the following components:

1. **Installation**: Installed as a dev dependency via Composer
2. **Configuration**: Published configuration to `config/microscope.php`
3. **CI Integration**: Added commands to the CI pipeline for automated checks

## Usage Examples

The tool can be used through various Artisan commands:

```bash
# Check route definitions for errors
php artisan check:routes

# Find controllers without routes
php artisan check:dead_controllers

# Identify bad coding practices
php artisan check:bad_practices

# Automatically refactor code using early returns
php artisan check:early_returns
```

## Technical Integration

Laravel Microscope works by statically analyzing the codebase to find potential issues. It examines:

- Route definitions and their corresponding controllers
- PSR-4 namespace compliance
- Facade usage and optimization opportunities
- Database queries in Blade templates
- Unused variables in views
- Anti-patterns and bad practices

For complete details on the integration, see the documentation at `docs/laravel-microscope.md`.

# Eloquent Has Many Deep Integration

## Overview

The Eloquent Has Many Deep package extends Laravel's relationship system by providing support for multilevel relationships. This integration enables advanced querying capabilities that span multiple models and relationship types.

## Features

- **Multilevel Relationships**: Define relationships that traverse through multiple models
- **Complex Relationship Chains**: Navigate through pivot tables, polymorphic relationships, and more
- **Optimized Performance**: Clean, maintainable code that generates efficient SQL queries
- **Enhanced Analytics**: Build powerful analytics features with minimal queries

## Implementation Details

The package has been integrated into key models to enable deep relationships:

1. **User Model**:
   - `taskComments()`: Comments on user's tasks
   - `taskTags()`: Tags used across user's tasks
   - `categoryTasks()`: Tasks belonging to user's categories
   - `categoryTaskComments()`: Comments on tasks within user's categories

2. **Category Model**:
   - `taskComments()`: Comments on tasks in this category
   - `taskTags()`: Tags used in tasks for this category
   - `taskAttachments()`: Attachments on tasks in this category

3. **Task Model**:
   - `commentReplies()`: Replies to comments on this task
   - `commenters()`: Users who have commented on this task

## Usage Examples

The following example demonstrates finding all comments on a user's tasks without needing complex queries:

```php
// Get all comments on the user's tasks with their authors
$comments = $user->taskComments()->with('user')->get();

// Find most used tags across user's tasks
$popularTags = $user->taskTags()
    ->select('tags.*', DB::raw('COUNT(*) as count'))
    ->groupBy('tags.id')
    ->orderByDesc('count')
    ->get();

// Get task engagement metrics
$metrics = $task->commenters()->count();
```

## API Integration

New analytics endpoints have been added to leverage these deep relationships:

- `/api/analytics/user/task-comments`: Get comments for the user's tasks
- `/api/analytics/user/task-tags`: Get tags used across the user's tasks
- `/api/analytics/tasks/{task}/engagement`: Get engagement metrics for a task
- `/api/analytics/categories/{category}/task-comments`: Get comments on category tasks

For complete documentation, see the dedicated file at `docs/eloquent-has-many-deep.md`.

# Laravel SOAP Integration

## Overview

The application integrates the `artisaninweb/laravel-soap` package to provide a structured approach for interacting with SOAP web services. This integration allows the application to communicate with external systems that expose SOAP APIs.

## Features

- **SOAP Client Wrapper**: Simplified interface for working with PHP's SOAP client
- **Configuration Management**: Central configuration for multiple SOAP services
- **Request/Response Objects**: Structured approach to handling SOAP requests and responses
- **Error Handling**: Comprehensive error handling and logging for SOAP operations
- **Facade Support**: Easy access to SOAP functionality via Laravel Facades
- **Service Provider**: Automatic registration and configuration of SOAP services

## Implementation Details

The SOAP integration is structured with the following components:

1. **Service Provider**: `app/Providers/SoapServiceProvider.php` registers SOAP services from configuration
2. **Configuration**: `config/soap.php` defines SOAP services, their endpoints, and authentication
3. **Request Objects**: `app/Soap/Requests/` contains request classes that encapsulate data for SOAP calls
4. **Response Objects**: `app/Soap/Responses/` contains classes for parsing and accessing SOAP responses
5. **Service Layer**: `app/Services/SoapService.php` handles the core SOAP operations
6. **Controller**: `app/Http/Controllers/SoapController.php` provides API endpoints for SOAP operations
7. **Routes**: API routes for accessing SOAP functionality

## Usage Example

The SOAP integration can be used in controllers or other services like this:

```php
// Create a request object
$request = new ExampleRequest(
    'John Doe', 
    'john@example.com', 
    'Test message'
);

// Execute the request through the service
$response = $soapService->executeExampleRequest($request);

// Use the response data
if ($response->isSuccess()) {
    $data = $response->getData();
    // Process the data
}
```

## API Endpoints

The following API endpoints are available for interacting with SOAP services:

- `POST /api/soap/example`: Submit data to a SOAP service
- `GET /api/soap/mock`: Get a mock SOAP response for testing

For more information, refer to the detailed documentation in `docs/laravel-soap.md`.

# Laravel Column Sortable Integration

## Overview

The application integrates Laravel Column Sortable, a package that provides an intuitive way to sort data tables by column headers in both backend queries and frontend UI. This integration enhances the user experience by allowing easy sorting of data lists with visual indicators.

## Features

- **Sortable Table Columns**: All data tables in the application support column sorting
- **Direction Indicators**: Visual indicators show current sort direction (ascending/descending)
- **Model Integration**: Models use the `Sortable` trait for sorting capabilities
- **Query Parameter Management**: Automatically handles URL query parameters
- **Relationship Column Sorting**: Support for sorting by relationship columns
- **Customizable Icons**: FontAwesome icons indicate sort direction

## Implementation Details

The Column Sortable integration is implemented in several key components:

1. **Models**: The `Sortable` trait is added to models that require sorting functionality (Task, User, Category)
2. **Controllers/Services**: Query builders use the `sortable()` method to apply sorting
3. **Views**: Table headers use the `@sortablelink` Blade directive to create sortable column links
4. **Configuration**: Custom configuration in `config/columnsortable.php` defines appearance and behavior

## Example Usage

Below is an example of how the Column Sortable integration is used in the application:

### Model Implementation

```php
use Kyslik\ColumnSortable\Sortable;

class Task extends Model
{
    use Sortable;

    public $sortable = [
        'id',
        'title',
        'due_date',
        'priority',
        'completed',
        'created_at',
        'updated_at'
    ];
}
```

### Controller/Service Implementation

```php
public function index(Request $request)
{
    $query = Task::query();
    
    // Apply filters
    if ($request->has('search')) {
        $query->search($request->search);
    }
    
    // Apply sorting using the Sortable trait
    if ($request->has('sort') || $request->has('direction')) {
        $query = $query->sortable($request->only(['sort', 'direction']));
    } else {
        // Default sorting
        $query->orderBy('created_at', 'desc');
    }
    
    $tasks = $query->paginate(15);
    
    return view('tasks.index', compact('tasks'));
}
```

### View Implementation

```blade
<th>@sortablelink('id', 'ID')</th>
<th>@sortablelink('title', 'Task Title')</th>
<th>@sortablelink('due_date', 'Due Date')</th>
<th>@sortablelink('priority', 'Priority')</th>
<th>@sortablelink('completed', 'Status')</th>
<th>@sortablelink('created_at', 'Created')</th>
```

The pagination links include all current query parameters to maintain sort state across pages.

For more information, see the full documentation in `docs/column-sortable.md`.

## Running Tests

The application includes a comprehensive test suite to ensure all API endpoints and functionality work as expected. To run tests correctly, use the custom Artisan command:

```bash
# Run all API tests with detailed output
php artisan app:run-api-tests

# Run specific API tests with a filter
php artisan app:run-api-tests --filter=TaskTest

# Generate code coverage report while running tests
php artisan app:run-api-tests --coverage
```

### Common Test Issues & Fixes

1. **RecursiveDirectoryIterator Error**: If you encounter `RecursiveDirectoryIterator::__construct(): Failed to open directory` error, do not run PHPUnit directly on individual test files. Use the Artisan command instead.

2. **Database Testing**: Tests use an in-memory SQLite database. Make sure your test environment variables are properly configured in the `.env.testing` file.

3. **Task Model Relationships**: The Task model requires proper relationships with Categories and Tags. Make sure these are properly defined in the models before running tests.

4. **API Response Format**: All API responses should follow the standard format with `success`, `message`, and `data` fields. Tests will fail if this format is not maintained.
